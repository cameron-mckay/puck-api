<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <title>PSIC Tags</title>
  </head>
  <body>
    <style>
        .console {
            background-color: #1e1e1e;
            color: #999999;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.9rem;
            height: 300px;
            overflow-y: auto;
            border-radius: 5px;
            border: 1px solid #444;
        }
        .console span {
            color: #00ff00;
        }
    </style>
    <script>

        let sensors = new Map()

        function logToConsole(networkId, message) {
            console.log(networkId)
            let consoleBox = document.getElementById("console_"+networkId)
            let d = new Date()
            consoleBox.innerHTML = consoleBox.innerHTML+d.toLocaleTimeString()+" - "+message+"<br>"
            consoleBox.scrollTop = consoleBox.scrollHeight;
        }
        function buildPage() {
            getData()
            .then(async (data)=>{
                let counts =  await Promise.all(data.map(async (n)=>{
                    return getMessageCountsOnNetwork(n.id)
                }))

                console.log(counts)
                for (let n of counts) {
                    if (n) {
                        for (let s of n) {
                            sensors.set(s.sensorId, s)
                        }
                    }
                }

                return data
            })
            .then((data)=>{
                let date = new Date()
                let body = document.getElementById("body")
                let html = `
                <div class="accordion" id="accordionPanelsStayOpenExample">
                    <h1>Puck Tester</h1>`;
                for(let i = 0; i < data.length; i++)
                {
                    let d = data[i]
                    html=html+`
                        <div class="accordion-item" id="network_${d.id}">
                            <h2 class="accordion-header" id="panelsStayOpen-heading${i+1}">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapse${i+1}" aria-expanded="false" aria-controls="panelsStayOpen-collapse${i+1}">
                                ${d.name}
                            </button>
                            </h2>
                            <div id="panelsStayOpen-collapse${i+1}" class="accordion-collapse collapse" aria-labelledby="panelsStayOpen-heading${i+1}">
                            <div class="accordion-body">
                                <h3>Logs:</h3>
                                <div class="console" id="console_${d.id}"></div>
                                <h3>Sensors:</h3>
                                <p>Last refreshed: <span id="lastupdate_${d.id}">${date.toLocaleString()}</span></p>
                                <table class="table table-striped table-dark">
                                    <thead>
                                        <tr>
                                        <th scope="col">ID</th>
                                        <th scope="col">Reading</th>
                                        <th scope="col">Time</th>
                                        <th scope="col">Status</th>
                                        <th scope="col">Battery</th>
                                        <th scope="col">Message Count</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tbody_${d.id}">`
                        for(let s of d.sensors) {
                            html=html+buildRow(s)
                        }
                        html=html+`

                                        </tbody>
                                    </table>
                                    <p class="form-label">Add batch to network: </p>
                                    <input class="form-control mb-2" type="text" id="batchId_${d.id}" placeholder="Batch ID"/>
                                    <button class="btn btn-primary mb-2" type="button" onclick="addBatch(${d.id})">Add Batch</button>
                                    <br>
                                    <button class="btn btn-danger" type="button" onclick="deleteOnNetwork(${d.id})">Clear network</button>
                                </div>
                            </div>
                        </div>`
                }
                html=html+`</div>`

                body.innerHTML = html
            })
        }

        function buildRow(sensor) {
            let extraData = sensors.has(sensor.SensorID) ? sensors.get(sensor.SensorID) : { minBattery: 100, count: 0, isDirty: false };

            let sensorClass = "table-success";

            if(!sensor.Online) {
                sensorClass = "table-secondary"
            }

            if(extraData.minBattery < 100 || extraData.count > 50 || extraData.isDirty) {
                sensorClass = "table-danger"
            }

            let btn = `<button class="btn btn-danger" type="button" onclick="setHeartbeat(${sensor.SensorID})">Fix Heartbeat</button>`
            return `
            <tr class="${sensorClass}">
                <td>${sensor.SensorID}</th>
                <td>${sensor.CurrentReading}</td>
                <td>${sensor.LastCommunicationDate.toLocaleString()}</td>
                <td>${sensor.Online?"Online":"Offline"}</td>
                <td>${extraData.minBattery}</td>
                <td class="d-flex justify-content-between"><div class="d-inline">${extraData.count}</div><div class="d-inlin">${extraData.count>50&&!extraData.isDirty?btn:""} ${extraData.isDirty==true?"Fix pending...":""}</div></td>
            </tr>
            `
        }

        function addBatch(networkId) {
            let batchId = parseInt(document.getElementById("batchId_"+networkId).value)
            if(isNaN(batchId)) {
                alert("Invalid batch ID")
                return
            }
            addBatchToNetwork(networkId, batchId)
        }
        function updatePage() {
            getData()
            .then((data)=>{
                for(let i = 0; i < data.length; i++)
                {
                    let d = data[i]
                    let table = document.getElementById("tbody_"+d.id)
                    let lastUpdate = document.getElementById("lastupdate_"+d.id)
                    lastUpdate.innerText = (new Date()).toLocaleString()
                    let html=``
                    for(let s of d.sensors) {
                        html=html+buildRow(s)
                    }
                    table.innerHTML = html
                }
            })
        }

        function getData() {
            return getNetworks()
            .then((networks)=>{
                return Promise.all(networks.map(async (network)=>{
                    let sensors = await getSensorsOnNetwork(network.NetworkID)
                    return {
                        id: network.NetworkID,
                        name: network.NetworkName,
                        sensors
                    }
                }))
            })
        }

        function updateSensors() {
            Promise.all(networkIds
            .map(async (id)=>{
                let sensors = await getSensorsOnNetwork(id)
                return {id, sensors }
            }))
            .then((sensors)=>{
                console.log(sensors)
            })
        }
        
        window.onload = function () {
            buildPage()
            setInterval(updatePage, 60000)
            var conn;
            var log = document.getElementById("log");

            function createWebsocket() {
                console.log("opening ws...")
                conn = new WebSocket("ws://" + document.location.host + "/ws");
                conn.onclose = function (evt) {
                    var item = document.createElement("div");
                    item.innerHTML = "<b>Connection closed.</b>";
                    setTimeout(createWebsocket, 1000)
                };
                conn.onmessage = function (evt) {
                    var messages = evt.data.split('\n');
                    for (var i = 0; i < messages.length; i++) {
                        let msg = JSON.parse(messages[i])
                        if (msg.sensorMessages) {
                            for(let m of msg.sensorMessages) {
                                let sensorId = m.sensorID
                                if(m.dataValue=="True")
                                    logToConsole(parseInt(msg.gatewayMessage.networkID), "Water detected on <span>"+sensorId+"</span>")
                            }
                        }
                    }
                };
                conn.onopen = (e) => {
                    console.log("ws opened.")
                }
                conn.onerror = (e) => {
                    console.log("ws failed.")
                }
            }
            if (window["WebSocket"]) {
                createWebsocket()
            } else {
                var item = document.createElement("div");
                item.innerHTML = "<b>Your browser does not support WebSockets.</b>";
                appendLog(item);
            }
        };

        var waiting = false

        function arrayToCSV(arr) {
            if(arr.length>0) {
                let first = arr[0]
                let keys = []
                let formattedKeys = []
                let values = []
                let csv = ""
                Object.keys(first).forEach((key)=>{
                    keys.push(key)
                    formattedKeys.push(key)
                })
                csv = formattedKeys.join(", ") + "\n"
                for(let obj of arr) {
                    values = []
                    for(let k of keys) {
                        let str = String(obj[k]).replaceAll(",","").replaceAll("\"","")
                        values.push(str)
                    }
                    csv += values.join(", ") + "\n"
                }
                return csv
            }
            return ""
        }

        function deleteOnNetwork(networkId) {
            if(waiting == true)
            {
                window.alert("Be patient.")
                return;
            }
            waiting = true;

            fetch("/api/deleteAllSensorsOnNetwork", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({networkId})
            }).then((res)=>{
                return res.text()
            })
            .then((text) => {
                window.alert(text)
                waiting = false;
                updatePage();
            })
            .catch((err)=>{
                window.alert(err)
                waiting = false;
            })
        }

        function setHeartbeat(sensorId) {
            fetch("/api/setHeartbeat", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({sensorId})
            }).then((res)=>{
                return res.text()
            })
            .then((text) => {
                window.alert(text)

                let s = sensors.get(sensorId)
                s.isDirty = true
                sensors.set(sensorId, s)
                updatePage();
            })
            .catch((err)=>{
                window.alert(err)
                waiting = false;
            })
        }

        function getNetworks() {
            return fetch("/api/getNetworks", {
                method: "GET",
                headers: {
                    "Content-Type": "application/json"
                },
            })
            .then((res)=>{
                return res.json()
            })
            .catch((err)=>{
                console.error(err)
            })

        }

        function getMessageCountsOnNetwork(networkId) {
            return fetch("/api/getMessageCountsOnNetwork", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({networkId})
            })
            .then((res)=>{
                return res.json()
            })
        }

        function getSensorsOnNetwork(networkId) {
            return fetch("/api/getSensorsOnNetwork", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({networkId})
            })
            .then((res)=>{
                return res.json()
            })
            .then((res)=>{
                let now = new Date()
                let future = new Date(4070908800001)
                return res.map((s)=>{
                    s.LastCommunicationDate = new Date(parseInt(s.LastCommunicationDate.match(/\d+/)[0]))
                    s.NextCommunicationDate = new Date(s.LastCommunicationDate.setHours(s.LastCommunicationDate.getHours()+2))
                    s.Online = now < s.NextCommunicationDate && s.NextCommunicationDate < future
                    return s
                })
            })
            .catch((err)=>{
                console.error(err)
            })
        }

        function addBatchToNetwork(networkId, binId) {
            return fetch("/api/addBinToNetwork", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({networkId, binId})
            })
            .then((res)=>{
                return res.text()
            })
            .then((text) => {
                window.alert(text)
                updatePage();
            })
            .catch((err)=>{
                window.alert(err)
            })
        }


    </script>
    <div class="container-sm mt-5" id="body">
    </div>
    <!-- Link to Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.min.js"></script>
  </body>
</html>
